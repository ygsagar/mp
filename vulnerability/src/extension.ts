//MAIN
// import * as vscode from 'vscode';
// import axios from 'axios';

// export function activate(context: vscode.ExtensionContext) {
//     // Create a status bar item for showing vulnerability status
//     const statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 100);
//     statusBarItem.text = 'Vulnerability Check: N/A';
//     statusBarItem.show();

//     // Function to check vulnerability of the code
//     const checkVulnerability = async (code: string) => {
//         if (!code) {
//             statusBarItem.text = 'Vulnerability Check: No code detected';
//             return;
//         }

//         try {
//             // Send the updated code to the Flask server for vulnerability prediction
//             // const response = await axios.post('http://127.0.0.1:5000/predict', { code });
//             const response = await axios.post('https://vuln-det-api-569954300851.asia-south1.run.app/predict', { code });
//             const result = response.data;

//             // Update the status bar with the vulnerability status
//             statusBarItem.text = `Vulnerability Check: ${result.vulnerability}`;
//             vscode.window.showInformationMessage(`Vulnerability Check: ${result.vulnerability}`);
//         } catch (error) {
//             console.error(error);
//             statusBarItem.text = 'Vulnerability Check: Error';
//             vscode.window.showErrorMessage('Failed to check vulnerability.');
//         }
//     };

//     // Event listener for changes in the active text document
//     vscode.workspace.onDidChangeTextDocument(async (event) => {
//         const activeEditor = vscode.window.activeTextEditor;

//         if (activeEditor && event.document === activeEditor.document) {
//             const code = activeEditor.document.getText();

//             // Check vulnerability on each change
//             await checkVulnerability(code);
//         }
//     });

//     // Register the manual command to check selected code for vulnerability
//     let disposable = vscode.commands.registerCommand('extension.checkVulnerability', async () => {
//         const editor = vscode.window.activeTextEditor;

//         if (editor) {
//             const code = editor.document.getText(editor.selection);

//             if (!code) {
//                 vscode.window.showErrorMessage('No code selected.');
//                 return;
//             }

//             // Check vulnerability of the selected code
//             await checkVulnerability(code);
//         }
//     });

//     context.subscriptions.push(disposable);
// }

// // This method is called when your extension is deactivated
// export function deactivate() {}

// // import * as vscode from 'vscode';
// // import axios from 'axios';

// // export function activate(context: vscode.ExtensionContext) {
// //     let disposable = vscode.commands.registerCommand('extension.checkVulnerability', async () => {
// //         const editor = vscode.window.activeTextEditor;

// //         if (editor) {
// //             const code = editor.document.getText(editor.selection);

// //             if (!code) {
// //                 vscode.window.showErrorMessage('No code selected.');
// //                 return;
// //             }

// //             try {
// //                 const response = await axios.post('http://127.0.0.1:5000/predict', {
// //                     code: code
// //                 });

// //                 const result = response.data;
// //                 vscode.window.showInformationMessage(`Vulnerability Check: ${result.vulnerability}`);
// //             } catch (error) {
// //                 console.error(error);
// //                 vscode.window.showErrorMessage('Failed to check vulnerability.');
// //             }
// //         }
// //     });

// //     context.subscriptions.push(disposable);
// // }

// // export function deactivate() {}








// //main

// // import * as vscode from 'vscode';
// // import axios from 'axios';

// // export function activate(context: vscode.ExtensionContext) {
// //     // Event listener for changes in the active text document
// //     const activeEditor = vscode.window.activeTextEditor;
// //     if (activeEditor) {
// //         vscode.workspace.onDidChangeTextDocument(async (event) => {
// //             if (event.document === activeEditor.document) {
// //                 const code = activeEditor.document.getText();

// //                 if (!code) {
// //                     vscode.window.showErrorMessage('No code detected.');
// //                     return;
// //                 }

// //                 try {
// //                     // Send the updated code to the Flask server for vulnerability prediction
// //                     const response = await axios.post('http://127.0.0.1:5000/predict', {
// //                         code: code
// //                     });

// //                     const result = response.data;

// //                     // Show the vulnerability status in the status bar
// //                     vscode.window.setStatusBarMessage(`Vulnerability Check: ${result.vulnerability}`, 5000);
// //                 } catch (error) {
// //                     console.error(error);
// //                     vscode.window.showErrorMessage('Failed to check vulnerability.');
// //                 }
// //             }
// //         });
// //     }

// //     // Register the manual command to check selected code for vulnerability
// //     let disposable = vscode.commands.registerCommand('extension.checkVulnerability', async () => {
// //         const editor = vscode.window.activeTextEditor;

// //         if (editor) {
// //             const code = editor.document.getText(editor.selection);

// //             if (!code) {
// //                 vscode.window.showErrorMessage('No code selected.');
// //                 return;
// //             }

// //             try {
// //                 const response = await axios.post('http://127.0.0.1:5000/predict', {
// //                     code: code
// //                 });

// //                 const result = response.data;
// //                 vscode.window.showInformationMessage(`Vulnerability Check: ${result.vulnerability}`);
// //             } catch (error) {
// //                 console.error(error);
// //                 vscode.window.showErrorMessage('Failed to check vulnerability.');
// //             }
// //         }
// //     });

// //     context.subscriptions.push(disposable);
// // }

// // export function deactivate() {}





// //throttle detection
// // import * as vscode from 'vscode';
// // import axios from 'axios';

// // // Throttle function to prevent too many API requests
// // function throttle(fn: Function, delay: number) {
// //     let lastCall = 0;
// //     return (...args: any[]) => {
// //         const now = new Date().getTime();
// //         if (now - lastCall < delay) {
// //             return;
// //         }
// //         lastCall = now;
// //         return fn(...args);
// //     };
// // }

// // export function activate(context: vscode.ExtensionContext) {
// //     const activeEditor = vscode.window.activeTextEditor;

// //     // Throttled vulnerability checking
// //     const throttledCheckVulnerability = throttle(async (code: string) => {
// //         try {
// //             const response = await axios.post('http://127.0.0.1:5000/predict', {
// //                 code: code
// //             });

// //             const result = response.data;
// //             const statusMessage = `Vulnerability Check: ${result.vulnerability}`;
            
// //             // Show the vulnerability status in the status bar
// //             vscode.window.setStatusBarMessage(statusMessage, 5000);
// //         } catch (error) {
// //             console.error(error);
// //             vscode.window.setStatusBarMessage('Failed to check vulnerability.', 5000);
// //         }
// //     }, 1000); // Throttle the function to run at most once every 1000ms (1 second)

// //     // Listen for text document changes
// //     vscode.workspace.onDidChangeTextDocument((event) => {
// //         const editor = vscode.window.activeTextEditor;

// //         if (editor && event.document === editor.document) {
// //             const code = editor.document.getText();

// //             if (code) {
// //                 throttledCheckVulnerability(code);
// //             }
// //         }
// //     });

// //     // You can still keep the manual command for checking vulnerabilities on selected code
// //     let disposable = vscode.commands.registerCommand('extension.checkVulnerability', async () => {
// //         const editor = vscode.window.activeTextEditor;

// //         if (editor) {
// //             const code = editor.document.getText(editor.selection);

// //             if (!code) {
// //                 vscode.window.showErrorMessage('No code selected.');
// //                 return;
// //             }

// //             try {
// //                 const response = await axios.post('http://127.0.0.1:5000/predict', {
// //                     code: code
// //                 });

// //                 const result = response.data;
// //                 vscode.window.showInformationMessage(`Vulnerability Check: ${result.vulnerability}`);
// //             } catch (error) {
// //                 console.error(error);
// //                 vscode.window.showErrorMessage('Failed to check vulnerability.');
// //             }
// //         }
// //     });

// //     context.subscriptions.push(disposable);
// // }

// // export function deactivate() {}



// //interacctive web panel
// // import * as vscode from 'vscode';
// // import axios from 'axios';

// // let diagnosticCollection: vscode.DiagnosticCollection;

// // export function activate(context: vscode.ExtensionContext) {
// //     diagnosticCollection = vscode.languages.createDiagnosticCollection('vulnerability');
    
// //     // Register command for the dashboard
// //     let disposable = vscode.commands.registerCommand('extension.checkVulnerability', async () => {
// //         const panel = vscode.window.createWebviewPanel(
// //             'vulnerabilityDashboard',
// //             'Vulnerability Dashboard',
// //             vscode.ViewColumn.One,
// //             { enableScripts: true }
// //         );

// //         // Set up HTML for the dashboard
// //         panel.webview.html = getDashboardHtml();

// //         const editor = vscode.window.activeTextEditor;

// //         if (editor) {
// //             const code = editor.document.getText();

// //             try {
// //                 const response = await axios.post('http://127.0.0.1:5000/predict', {
// //                     code: code
// //                 });

// //                 const result = response.data;

// //                 // Update dashboard with the vulnerability result
// //                 panel.webview.postMessage({
// //                     type: 'vulnerabilityCheck',
// //                     result: result.vulnerability,
// //                     probabilities: result.probabilities
// //                 });

// //             } catch (error) {
// //                 console.error(error);
// //                 vscode.window.showErrorMessage('Failed to check vulnerability.');
// //             }
// //         }
// //     });

// //     context.subscriptions.push(disposable);
// // }

// // // Dashboard HTML content
// // function getDashboardHtml(): string {
// //     return `
// //     <!DOCTYPE html>
// //     <html lang="en">
// //     <head>
// //         <meta charset="UTF-8">
// //         <meta name="viewport" content="width=device-width, initial-scale=1.0">
// //         <title>Vulnerability Dashboard</title>
// //         <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
// //     </head>
// //     <body>
// //         <h1>Vulnerability Dashboard</h1>
// //         <div>
// //             <h3>Vulnerability Summary:</h3>
// //             <p id="vulnerabilityStatus">Checking...</p>
// //         </div>
// //         <div>
// //             <h3>Vulnerability Severity:</h3>
// //             <canvas id="severityChart" width="400" height="200"></canvas>
// //         </div>

// //         <script>
// //             const vscode = acquireVsCodeApi();

// //             // Update vulnerability status from extension
// //             window.addEventListener('message', event => {
// //                 const message = event.data;
// //                 if (message.type === 'vulnerabilityCheck') {
// //                     document.getElementById('vulnerabilityStatus').innerText = 'Vulnerability Status: ' + message.result;

// //                     // Update chart
// //                     const ctx = document.getElementById('severityChart').getContext('2d');
// //                     new Chart(ctx, {
// //                         type: 'bar',
// //                         data: {
// //                             labels: ['Safe', 'Vulnerable'],
// //                             datasets: [{
// //                                 label: 'Vulnerability Probability',
// //                                 data: message.probabilities,
// //                                 backgroundColor: ['green', 'red']
// //                             }]
// //                         },
// //                         options: {
// //                             scales: {
// //                                 y: {
// //                                     beginAtZero: true
// //                                 }
// //                             }
// //                         }
// //                     });
// //                 }
// //             });
// //         </script>
// //     </body>
// //     </html>
// //     `;
// // }

// // export function deactivate() {
// //     if (diagnosticCollection) {
// //         diagnosticCollection.dispose();
// //     }
// // }

// //highlighting the errors
// // import * as vscode from 'vscode';
// // import axios from 'axios';

// // let diagnosticCollection: vscode.DiagnosticCollection;

// // export function activate(context: vscode.ExtensionContext) {
// //     diagnosticCollection = vscode.languages.createDiagnosticCollection('vulnerability');
// //     let disposable = vscode.commands.registerCommand('extension.checkVulnerability', async () => {
// //         const editor = vscode.window.activeTextEditor;

// //         if (editor) {
// //             const code = editor.document.getText(editor.selection);

// //             if (!code) {
// //                 vscode.window.showErrorMessage('No code selected.');
// //                 return;
// //             }

// //             try {
// //                 // Send code to API
// //                 const response = await axios.post('http://127.0.0.1:5000/predict', {
// //                     code: code
// //                 });

// //                 const result = response.data;

// //                 // Status bar update
// //                 vscode.window.setStatusBarMessage(`Vulnerability: ${result.vulnerability}`, 5000);

// //                 // Inline diagnostics (warnings/errors)
// //                 let diagnostics: vscode.Diagnostic[] = [];
// //                 if (result.vulnerability === 'Vulnerable') {
// //                     const diagnostic = new vscode.Diagnostic(editor.selection, 'Code is vulnerable', vscode.DiagnosticSeverity.Warning);
// //                     diagnostics.push(diagnostic);
// //                 }
// //                 diagnosticCollection.set(editor.document.uri, diagnostics);

// //             } catch (error) {
// //                 console.error(error);
// //                 vscode.window.showErrorMessage('Failed to check vulnerability.');
// //             }
// //         }
// //     });

// //     // Real-time detection (example every second)
// //     const realTimeCheck = vscode.workspace.onDidChangeTextDocument(async (event) => {
// //         const editor = vscode.window.activeTextEditor;
// //         if (!editor || !editor.document) return;

// //         const code = editor.document.getText();

// //         try {
// //             const response = await axios.post('http://127.0.0.1:5000/predict', {
// //                 code: code
// //             });

// //             const result = response.data;
// //             vscode.window.setStatusBarMessage(`Real-time check: ${result.vulnerability}`, 3000);

// //             // Clear existing diagnostics and set new ones
// //             let diagnostics: vscode.Diagnostic[] = [];
// //             if (result.vulnerability === 'Vulnerable') {
// //                 const diagnostic = new vscode.Diagnostic(new vscode.Range(0, 0, editor.document.lineCount, 0), 'Vulnerability detected', vscode.DiagnosticSeverity.Warning);
// //                 diagnostics.push(diagnostic);
// //             }
// //             diagnosticCollection.set(editor.document.uri, diagnostics);
// //         } catch (error) {
// //             vscode.window.showErrorMessage('Real-time check failed.');
// //         }
// //     });

// //     context.subscriptions.push(disposable, realTimeCheck);
// // }

// // export function deactivate() {
// //     if (diagnosticCollection) {
// //         diagnosticCollection.dispose();
// //     }
// // }


// //smart vul detection
// // import * as vscode from 'vscode';
// // import axios from 'axios';
// // import * as nodemailer from 'nodemailer';

// // let diagnosticCollection: vscode.DiagnosticCollection;

// // export function activate(context: vscode.ExtensionContext) {
// //     diagnosticCollection = vscode.languages.createDiagnosticCollection('vulnerability');

// //     // Register command for real-time vulnerability detection
// //     let disposable = vscode.commands.registerCommand('extension.checkVulnerability', async () => {
// //         const editor = vscode.window.activeTextEditor;

// //         if (editor) {
// //             const code = editor.document.getText(editor.selection);

// //             if (!code) {
// //                 vscode.window.showErrorMessage('No code selected.');
// //                 return;
// //             }

// //             try {
// //                 // Send code to API
// //                 const response = await axios.post('http://127.0.0.1:5000/predict', {
// //                     code: code
// //                 });

// //                 const result = response.data;

// //                 // Show result as a notification
// //                 vscode.window.showInformationMessage(`Vulnerability Check: ${result.vulnerability}`);

// //                 // Generate inline diagnostics
// //                 let diagnostics: vscode.Diagnostic[] = [];
// //                 if (result.vulnerability === 'Vulnerable') {
// //                     const diagnostic = new vscode.Diagnostic(editor.selection, 'Code is vulnerable', vscode.DiagnosticSeverity.Warning);
// //                     diagnostics.push(diagnostic);
// //                 }
// //                 diagnosticCollection.set(editor.document.uri, diagnostics);

// //             } catch (error) {
// //                 console.error(error);
// //                 vscode.window.showErrorMessage('Failed to check vulnerability.');
// //             }
// //         }
// //     });

// //     // Command to generate a detailed report
// //     let reportDisposable = vscode.commands.registerCommand('extension.generateReport', async () => {
// //         const editor = vscode.window.activeTextEditor;

// //         if (editor) {
// //             const code = editor.document.getText();
// //             const filename = editor.document.fileName;

// //             try {
// //                 // Send code to API
// //                 const response = await axios.post('http://127.0.0.1:5000/predict', {
// //                     code: code
// //                 });

// //                 const result = response.data;
// //                 const vulnerabilityReport = `
// //                     File: ${filename}
// //                     Vulnerability: ${result.vulnerability}
// //                     Probabilities: ${result.probabilities.join(', ')}
// //                 `;

// //                 // Generate a shareable report
// //                 await shareReport(vulnerabilityReport);

// //                 vscode.window.showInformationMessage('Vulnerability report generated and shared.');

// //             } catch (error) {
// //                 console.error(error);
// //                 vscode.window.showErrorMessage('Failed to generate report.');
// //             }
// //         }
// //     });

// //     context.subscriptions.push(disposable, reportDisposable);
// // }

// // async function shareReport(report: string) {
// //     // Dummy email sending logic using nodemailer (replace with real credentials or setup)
// //     let transporter = nodemailer.createTransport({
// //         service: 'gmail',
// //         auth: {
// //             user: '@gmail.com',
// //             pass: 'your-password'
// //         }
// //     });

// //     let mailOptions = {
// //         from: 'your-email@gmail.com',
// //         to: 'recipient-email@example.com',
// //         subject: 'Vulnerability Report',
// //         text: report
// //     };

// //     try {
// //         await transporter.sendMail(mailOptions);
// //         console.log('Report emailed successfully.');
// //     } catch (error) {
// //         console.error('Error sending email:', error);
// //     }
// // }

// // export function deactivate() {
// //     if (diagnosticCollection) {
// //         diagnosticCollection.dispose();
// //     }
// // }




// // for each change real time

// ////////////////////////////////////------------------////////////////////
// ////////////////////////////////////------------------////////////////////
// ////////////////////////////////////------------------////////////////////
// ////////////////////////////////////------------------////////////////////
// ////////////////////////////////////------------------////////////////////

// ////MAIN/////

// // import * as vscode from 'vscode';
// // import axios from 'axios';

// // export function activate(context: vscode.ExtensionContext) {
// //     // Create a status bar item for showing vulnerability status
// //     const statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 100);
// //     statusBarItem.text = 'Vulnerability Check: N/A';
// //     statusBarItem.show();

// //     // Function to check vulnerability of the code
// //     const checkVulnerability = async (code: string) => {
// //         if (!code) {
// //             statusBarItem.text = 'Vulnerability Check: No code detected';
// //             return;
// //         }

// //         try {
// //             // Send the updated code to the Flask server for vulnerability prediction
// //             console.time('Vulnerability Check Response Time');
// //             const response = await axios.post('http://127.0.0.1:5000/predict', { code });
// //             const result = response.data;
// //             console.timeEnd('Vulnerability Check Response Time');

// //             // Update the status bar with the vulnerability status
// //             statusBarItem.text = `Vulnerability Check: ${result.vulnerability}`;
// //             vscode.window.showInformationMessage(`Vulnerability Check: ${result.vulnerability}`);
// //         } catch (error) {
// //             console.error(error);
// //             statusBarItem.text = 'Vulnerability Check: Error';
// //             vscode.window.showErrorMessage('Failed to check vulnerability.');
// //         }
// //     };

// //     // Event listener for changes in the active text document
// //     vscode.workspace.onDidChangeTextDocument(async (event) => {
// //         const activeEditor = vscode.window.activeTextEditor;

// //         if (activeEditor && event.document === activeEditor.document) {
// //             const code = activeEditor.document.getText();

// //             // Check vulnerability on each change
// //             await checkVulnerability(code);
// //         }
// //     });

// //     // Register the manual command to check selected code for vulnerability
// //     let disposable = vscode.commands.registerCommand('extension.checkVulnerability', async () => {
// //         const editor = vscode.window.activeTextEditor;

// //         if (editor) {
// //             const code = editor.document.getText(editor.selection);

// //             if (!code) {
// //                 vscode.window.showErrorMessage('No code selected.');
// //                 return;
// //             }

// //             // Check vulnerability of the selected code
// //             await checkVulnerability(code);
// //         }
// //     });

// //     context.subscriptions.push(disposable);
// // }

// // // This method is called when your extension is deactivated
// // export function deactivate() {}


// ////////////////////////////////////------------------////////////////////
// ////////////////////////////////////------------------////////////////////
// ////////////////////////////////////------------------////////////////////
// ////////////////////////////////////------------------////////////////////
// ////////////////////////////////////------------------////////////////////
// ////////////////////////////////////------------------////////////////////



// // import * as vscode from 'vscode';
// // import axios from 'axios';

// // export function activate(context: vscode.ExtensionContext) {
// //     // Create a status bar item for showing vulnerability status
// //     const statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 100);
// //     statusBarItem.text = 'Vulnerability Check: N/A';
// //     statusBarItem.show();

// //     // Function to check vulnerability of the code
// //     const checkVulnerability = async (code: string) => {
// //         if (!code) {
// //             statusBarItem.text = 'Vulnerability Check: No code detected';
// //             return;
// //         }

// //         // Check if code contains multiple lines
// //         const lineCount = code.split('\n').length;
// //         if (lineCount > 1) {
// //             const errorMessage = 'Vulnerability Check: Error';
// //             vscode.window.showErrorMessage(errorMessage);
// //             statusBarItem.text = errorMessage;
// //             return;
// //         }

// //         try {
// //             // Send the updated code to the Flask server for vulnerability prediction
// //             const response = await axios.post('http://127.0.0.1:5000/predict', { code });
// //             const result = response.data;

// //             // Update the status bar with the vulnerability status
// //             statusBarItem.text = `Vulnerability Check: ${result.vulnerability}`;
// //         } catch (error) {
// //             console.error(error);
// //             statusBarItem.text = 'Vulnerability Check: Error';
// //             vscode.window.showErrorMessage('Failed to check vulnerability.');
// //         }
// //     };

// //     // Event listener for changes in the active text document
// //     vscode.workspace.onDidChangeTextDocument(async (event) => {
// //         const activeEditor = vscode.window.activeTextEditor;

// //         if (activeEditor && event.document === activeEditor.document) {
// //             const code = activeEditor.document.getText();

// //             // Check vulnerability on each change
// //             await checkVulnerability(code);
// //         }
// //     });

// //     // Register the manual command to check selected code for vulnerability
// //     let disposable = vscode.commands.registerCommand('extension.checkVulnerability', async () => {
// //         const editor = vscode.window.activeTextEditor;

// //         if (editor) {
// //             const code = editor.document.getText(editor.selection);

// //             if (!code) {
// //                 vscode.window.showErrorMessage('No code selected.');
// //                 return;
// //             }

// //             // Check vulnerability of the selected code
// //             await checkVulnerability(code);
// //         }
// //     });

// //     context.subscriptions.push(disposable);
// // }

// // // This method is called when your extension is deactivated
// // export function deactivate() {}




// //Adding comments
// // import * as vscode from 'vscode';
// // import axios from 'axios';

// // export function activate(context: vscode.ExtensionContext) {
// //     // Create a status bar item for showing vulnerability status
// //     const statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 100);
// //     statusBarItem.text = 'Vulnerability Check: N/A';
// //     statusBarItem.show();

// //     // Function to add comment to the vulnerable line
// //     const addCommentToVulnerableLine = (editor: vscode.TextEditor, range: vscode.Range) => {
// //         const comment = '// Warning: Potential SQL injection vulnerability detected';
// //         editor.edit(editBuilder => {
// //             editBuilder.insert(range.start, comment + '\n');
// //         });
// //     };

// //     // Function to check vulnerability of the code
// //     const checkVulnerability = async (code: string, document: vscode.TextDocument) => {
// //         if (!code) {
// //             statusBarItem.text = 'Vulnerability Check: No code detected';
// //             return;
// //         }

// //         try {
// //             // Send the updated code to the Flask server for vulnerability prediction
// //             const response = await axios.post('http://127.0.0.1:5000/predict', { code });
// //             const result = response.data;

// //             // Update the status bar with the vulnerability status
// //             statusBarItem.text = `Vulnerability Check: ${result.vulnerability}`;

// //             // If a vulnerability is detected, add a comment to the line
// //             if (result.vulnerability === 'Vulnerable') {
// //                 const editor = vscode.window.activeTextEditor;
// //                 if (editor) {
// //                     const range = new vscode.Range(document.positionAt(0), document.positionAt(code.length));
// //                     addCommentToVulnerableLine(editor, range);
// //                 }
// //             }
// //         } catch (error) {
// //             console.error(error);
// //             statusBarItem.text = 'Vulnerability Check: Error';
// //             vscode.window.showErrorMessage('Failed to check vulnerability.');
// //         }
// //     };

// //     // Event listener for changes in the active text document
// //     vscode.workspace.onDidChangeTextDocument(async (event) => {
// //         const activeEditor = vscode.window.activeTextEditor;

// //         if (activeEditor && event.document === activeEditor.document) {
// //             const code = activeEditor.document.getText();

// //             // Check vulnerability on each change
// //             await checkVulnerability(code, event.document);
// //         }
// //     });

// //     // Register the manual command to check selected code for vulnerability
// //     let disposable = vscode.commands.registerCommand('extension.checkVulnerability', async () => {
// //         const editor = vscode.window.activeTextEditor;

// //         if (editor) {
// //             const code = editor.document.getText(editor.selection);

// //             if (!code) {
// //                 vscode.window.showErrorMessage('No code selected.');
// //                 return;
// //             }

// //             // Check vulnerability of the selected code
// //             await checkVulnerability(code, editor.document);
// //         }
// //     });

// //     context.subscriptions.push(disposable);
// // }

// // // This method is called when your extension is deactivated
// // export function deactivate() {}








// //web panel
// // import * as vscode from 'vscode';
// // import axios from 'axios';

// // export function activate(context: vscode.ExtensionContext) {
// //     // Create a status bar item for showing vulnerability status
// //     const statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 100);
// //     statusBarItem.text = 'Vulnerability Check: N/A';
// //     statusBarItem.show();

// //     // Function to display a vulnerability report in a webview panel
// //     const showVulnerabilityReport = (vulnerabilityDetails: string) => {
// //         const panel = vscode.window.createWebviewPanel(
// //             'vulnerabilityReport', 
// //             'Vulnerability Report', 
// //             vscode.ViewColumn.One, 
// //             {}
// //         );
        
// //         // Construct HTML content for the report
// //         panel.webview.html = `
// //             <html>
// //             <body>
// //                 <h1>Vulnerability Report</h1>
// //                 <p>${vulnerabilityDetails}</p>
// //                 <h2>Suggested Fixes:</h2>
// //                 <p>Consider using prepared statements to prevent SQL injection attacks.</p>
// //             </body>
// //             </html>
// //         `;
// //     };

// //     // Function to check vulnerability of the code
// //     const checkVulnerability = async (code: string) => {
// //         if (!code) {
// //             statusBarItem.text = 'Vulnerability Check: No code detected';
// //             return;
// //         }

// //         try {
// //             // Send the updated code to the Flask server for vulnerability prediction
// //             const response = await axios.post('http://127.0.0.1:5000/predict', { code });
// //             const result = response.data;

// //             // Update the status bar with the vulnerability status
// //             statusBarItem.text = `Vulnerability Check: ${result.vulnerability}`;

// //             // Show the vulnerability report if the code is vulnerable
// //             if (result.vulnerability === 'Vulnerable') {
// //                 const vulnerabilityDetails = `Code: ${code}\nPrediction: Vulnerable`;
// //                 showVulnerabilityReport(vulnerabilityDetails);
// //             }

// //         } catch (error) {
// //             console.error(error);
// //             statusBarItem.text = 'Vulnerability Check: Error';
// //             vscode.window.showErrorMessage('Failed to check vulnerability.');
// //         }
// //     };

// //     // Event listener for changes in the active text document
// //     vscode.workspace.onDidChangeTextDocument(async (event) => {
// //         const activeEditor = vscode.window.activeTextEditor;

// //         if (activeEditor && event.document === activeEditor.document) {
// //             const code = activeEditor.document.getText();

// //             // Check vulnerability on each change
// //             await checkVulnerability(code);
// //         }
// //     });

// //     // Register the manual command to check selected code for vulnerability
// //     let disposable = vscode.commands.registerCommand('extension.checkVulnerability', async () => {
// //         const editor = vscode.window.activeTextEditor;

// //         if (editor) {
// //             const code = editor.document.getText(editor.selection);

// //             if (!code) {
// //                 vscode.window.showErrorMessage('No code selected.');
// //                 return;
// //             }

// //             // Check vulnerability of the selected code
// //             await checkVulnerability(code);
// //         }
// //     });

// //     context.subscriptions.push(disposable);
// // }

// // // This method is called when your extension is deactivated
// // export function deactivate() {}





// //different types of files

// // import * as vscode from 'vscode';
// // import axios from 'axios';

// // export function activate(context: vscode.ExtensionContext) {
// //     // Create a status bar item for showing vulnerability status
// //     const statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 100);
// //     statusBarItem.text = 'Vulnerability Check: N/A';
// //     statusBarItem.show();

// //     // Function to check the vulnerability of the code
// //     const checkVulnerability = async (code: string, fileType: string) => {
// //         if (!code) {
// //             statusBarItem.text = 'Vulnerability Check: No code detected';
// //             return;
// //         }

// //         try {
// //             // Send the updated code and file type to the Flask server for vulnerability prediction
// //             const response = await axios.post('http://127.0.0.1:5000/predict', {
// //                 code,
// //                 fileType  // Include the file type (e.g., cpp, c, python)
// //             });
// //             const result = response.data;

// //             // Update the status bar with the vulnerability status
// //             statusBarItem.text = `Vulnerability Check: ${result.vulnerability}`;
// //         } catch (error) {
// //             console.error(error);
// //             statusBarItem.text = 'Vulnerability Check: Error';
// //             vscode.window.showErrorMessage('Failed to check vulnerability.');
// //         }
// //     };

// //     // Event listener for changes in the active text document
// //     vscode.workspace.onDidChangeTextDocument(async (event) => {
// //         const activeEditor = vscode.window.activeTextEditor;

// //         if (activeEditor && event.document === activeEditor.document) {
// //             const code = activeEditor.document.getText();
// //             const fileType = getFileType(activeEditor.document.fileName);

// //             // Check vulnerability on each change, with file type
// //             await checkVulnerability(code, fileType);
// //         }
// //     });

// //     // Register the manual command to check selected code for vulnerability
// //     let disposable = vscode.commands.registerCommand('extension.checkVulnerability', async () => {
// //         const editor = vscode.window.activeTextEditor;

// //         if (editor) {
// //             const code = editor.document.getText(editor.selection);
// //             const fileType = getFileType(editor.document.fileName);

// //             if (!code) {
// //                 vscode.window.showErrorMessage('No code selected.');
// //                 return;
// //             }

// //             // Check vulnerability of the selected code with file type
// //             await checkVulnerability(code, fileType);
// //         }
// //     });

// //     context.subscriptions.push(disposable);
// // }

// // // Helper function to get the file type based on file extension
// // function getFileType(fileName: string): string {
// //     const fileExtension = fileName.split('.').pop();
    
// //     if (fileExtension === 'cpp' || fileExtension === 'c') {
// //         return 'cpp';  // Handle C/C++ files
// //     } else if (fileExtension === 'py') {
// //         return 'python';  // Handle Python files
// //     }
    
// //     // Return 'unknown' if it's not a recognized file type
// //     return 'unknown';
// // }

// // // This method is called when your extension is deactivated
// // export function deactivate() {}





// // import * as vscode from 'vscode';
// // import axios from 'axios';
// // import { writeFileSync } from 'fs';
// // import * as path from 'path';

// // let responseTimes: number[] = []; // Array to hold response times
// // let probabilities: number[][] = []; // Array to hold probabilities for each check

// // export function activate(context: vscode.ExtensionContext) {
// //     // Create a status bar item for showing vulnerability status
// //     const statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 100);
// //     statusBarItem.text = 'Vulnerability Check: N/A';
// //     statusBarItem.show();

// //     // Function to check vulnerability of the code
// //     const checkVulnerability = async (code: string) => {
// //         if (!code) {
// //             statusBarItem.text = 'Vulnerability Check: No code detected';
// //             return;
// //         }

// //         const startTime = performance.now(); // Start time measurement

// //         try {
// //             // Send the updated code to the Flask server for vulnerability prediction
// //             const response = await axios.post('http://127.0.0.1:5000/predict', { code });
// //             const result = response.data;

// //             // Calculate response time
// //             const endTime = performance.now();
// //             const responseTime = endTime - startTime;
// //             responseTimes.push(responseTime); // Store response time
// //             probabilities.push(result.probabilities); // Store probabilities

// //             // Update the status bar with the vulnerability status
// //             statusBarItem.text = `Vulnerability Check: ${result.vulnerability} (Response Time: ${responseTime.toFixed(2)} ms)`;
// //             vscode.window.showInformationMessage(`Vulnerability Check: ${result.vulnerability} (Response Time: ${responseTime.toFixed(2)} ms)`);
// //         } catch (error) {
// //             console.error(error);
// //             statusBarItem.text = 'Vulnerability Check: Error';
// //             vscode.window.showErrorMessage('Failed to check vulnerability.');
// //         }
// //     };

// //     // Command to show response time graph
// //     let showGraphDisposable = vscode.commands.registerCommand('extension.showResponseTimeGraph', async () => {
// //         const htmlPath = path.join(context.extensionPath, 'responseTimeGraph.html');
// //         writeFileSync(htmlPath, generateGraphHTML(responseTimes, probabilities));
// //         const panel = vscode.window.createWebviewPanel(
// //             'responseTimeGraph', // Identifies the type of the webview
// //             'Response Time and Probability Graph', // Title of the panel
// //             vscode.ViewColumn.One, // Show the webview in the first column
// //             {} // Webview options
// //         );
// //         panel.webview.html = getWebviewContent(htmlPath);
// //     });

// //     context.subscriptions.push(showGraphDisposable);

// //     // Event listener for changes in the active text document
// //     vscode.workspace.onDidChangeTextDocument(async (event) => {
// //         const activeEditor = vscode.window.activeTextEditor;

// //         if (activeEditor && event.document === activeEditor.document) {
// //             const code = activeEditor.document.getText();

// //             // Check vulnerability on each change
// //             await checkVulnerability(code);
// //         }
// //     });

// //     // Register the manual command to check selected code for vulnerability
// //     let disposable = vscode.commands.registerCommand('extension.checkVulnerability', async () => {
// //         const editor = vscode.window.activeTextEditor;

// //         if (editor) {
// //             const code = editor.document.getText(editor.selection);

// //             if (!code) {
// //                 vscode.window.showErrorMessage('No code selected.');
// //                 return;
// //             }

// //             // Check vulnerability of the selected code
// //             await checkVulnerability(code);
// //         }
// //     });

// //     context.subscriptions.push(disposable);
// // }

// // // Function to generate the HTML for the graph
// // function generateGraphHTML(responseTimes: number[], probabilities: number[][]): string {
// //     return `
// //     <!DOCTYPE html>
// //     <html lang="en">
// //     <head>
// //         <meta charset="UTF-8">
// //         <meta name="viewport" content="width=device-width, initial-scale=1.0">
// //         <title>Response Time and Probability Graph</title>
// //         <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
// //     </head>
// //     <body>
// //         <h2>Response Time and Probability Graph</h2>
// //         <canvas id="responseTimeChart" width="400" height="200"></canvas>
// //         <script>
// //             const ctx = document.getElementById('responseTimeChart').getContext('2d');
// //             const responseTimes = ${JSON.stringify(responseTimes)};
// //             const probabilities = ${JSON.stringify(probabilities)};

// //             const chart = new Chart(ctx, {
// //                 type: 'line',
// //                 data: {
// //                     labels: responseTimes.map((_, index) => 'Check ' + (index + 1)),
// //                     datasets: [{
// //                         label: 'Response Time (ms)',
// //                         data: responseTimes,
// //                         borderColor: 'rgba(75, 192, 192, 1)',
// //                         backgroundColor: 'rgba(75, 192, 192, 0.2)',
// //                         fill: true,
// //                     },
// //                     {
// //                         label: 'Probability of Vulnerability',
// //                         data: probabilities.map(p => p[1] || 0), // Assuming the second element is the probability of vulnerability
// //                         borderColor: 'rgba(255, 99, 132, 1)',
// //                         backgroundColor: 'rgba(255, 99, 132, 0.2)',
// //                         fill: false,
// //                     }]
// //                 },
// //                 options: {
// //                     scales: {
// //                         y: {
// //                             beginAtZero: true
// //                         }
// //                     }
// //                 }
// //             });
// //         </script>
// //     </body>
// //     </html>
// //     `;
// // }

// // // Function to get the webview content
// // function getWebviewContent(htmlPath: string): string {
// //     const content = readFileSync(htmlPath, 'utf-8');
// //     return content;
// // }

// // // This method is called when your extension is deactivated
// // export function deactivate() {}





// ///////////////////FIXING-SUGGESTION///////////////////
// // import * as vscode from 'vscode';
// // import axios from 'axios';

// // export function activate(context: vscode.ExtensionContext) {
// //     // Create a status bar item for showing vulnerability status and fix suggestions
// //     const statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 100);
// //     statusBarItem.text = 'Vulnerability Check: N/A';
// //     statusBarItem.show();

// //     // Function to check vulnerability of the code and show fix suggestion
// //     const checkVulnerability = async (code: string) => {
// //         if (!code) {
// //             statusBarItem.text = 'Vulnerability Check: No code detected';
// //             return;
// //         }

// //         try {
// //             // Send the updated code to the Flask server for vulnerability prediction
// //             console.time('Vulnerability Check Response Time');
// //             const response = await axios.post('http://127.0.0.1:5000/predict', { code });
// //             const result = response.data;
// //             console.timeEnd('Vulnerability Check Response Time');

// //             // Update the status bar with the vulnerability status
// //             statusBarItem.text = `Vulnerability Check: ${result.vulnerability}`;
// //             vscode.window.showInformationMessage(`Vulnerability Check: ${result.vulnerability}`);

// //             // Show the fix suggestion if any
// //             if (result.fix_suggestion) {
// //                 vscode.window.showInformationMessage(`Fix Suggestion: ${result.fix_suggestion}`);
// //             }

// //         } catch (error) {
// //             console.error(error);
// //             statusBarItem.text = 'Vulnerability Check: Error';
// //             vscode.window.showErrorMessage('Failed to check vulnerability.');
// //         }
// //     };

// //     // Event listener for changes in the active text document
// //     vscode.workspace.onDidChangeTextDocument(async (event) => {
// //         const activeEditor = vscode.window.activeTextEditor;

// //         if (activeEditor && event.document === activeEditor.document) {
// //             const code = activeEditor.document.getText();

// //             // Check vulnerability on each change
// //             await checkVulnerability(code);
// //         }
// //     });

// //     // Register the manual command to check selected code for vulnerability
// //     let disposable = vscode.commands.registerCommand('extension.checkVulnerability', async () => {
// //         const editor = vscode.window.activeTextEditor;

// //         if (editor) {
// //             const code = editor.document.getText(editor.selection);

// //             if (!code) {
// //                 vscode.window.showErrorMessage('No code selected.');
// //                 return;
// //             }

// //             // Check vulnerability of the selected code
// //             await checkVulnerability(code);
// //         }
// //     });

// //     context.subscriptions.push(disposable);
// // }

// // // This method is called when your extension is deactivated
// // export function deactivate() {}



// /////////////////////////              CORRECTING           /////////////////
// // import * as vscode from 'vscode';
// // import axios from 'axios';

// // export function activate(context: vscode.ExtensionContext) {
// //     // Create a status bar item for showing vulnerability status
// //     const statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 100);
// //     statusBarItem.text = 'Vulnerability Check: N/A';
// //     statusBarItem.show();

// //     // Function to check vulnerability of the code
// //     const checkVulnerability = async (code: string) => {
// //         if (!code) {
// //             statusBarItem.text = 'Vulnerability Check: No code detected';
// //             return;
// //         }

// //         try {
// //             // Send the updated code to the Flask server for vulnerability prediction
// //             console.time('Vulnerability Check Response Time');
// //             const response = await axios.post('http://127.0.0.1:5000/predict', { code });
// //             const result = response.data;
// //             console.timeEnd('Vulnerability Check Response Time');

// //             // Update the status bar with the vulnerability status
// //             statusBarItem.text = `Vulnerability Check: ${result.vulnerability}`;
// //             vscode.window.showInformationMessage(`Vulnerability Check: ${result.vulnerability}`);

// //             // If vulnerable, ask the user to apply the fix
// //             if (result.vulnerability === 'Vulnerable') {
// //                 const applyFix = await vscode.window.showInformationMessage('Would you like to apply the fix?', 'Yes', 'No');
// //                 if (applyFix === 'Yes') {
// //                     // Apply the fix: Replace with parameterized query
// //                     const fixedCode = code.replace(
// //                         /f"SELECT \* FROM users WHERE username = '([^']+)'"/g,
// //                         `query = "SELECT * FROM users WHERE username = ?"`
// //                     );

// //                     // Update the document with the fixed code
// //                     const activeEditor = vscode.window.activeTextEditor;
// //                     if (activeEditor) {
// //                         const document = activeEditor.document;
// //                         const edit = new vscode.WorkspaceEdit();
// //                         const startPosition = new vscode.Position(0, 0);
// //                         const endPosition = document.lineAt(document.lineCount - 1).range.end;

// //                         // Replace the entire document content with the fixed code
// //                         edit.replace(document.uri, new vscode.Range(startPosition, endPosition), fixedCode);
// //                         await vscode.workspace.applyEdit(edit);
// //                     }

// //                     vscode.window.showInformationMessage('Fix applied successfully!');

// //                     // Recheck the code after applying the fix
// //                     await checkVulnerability(fixedCode);  // Send the fixed code for a new vulnerability check
// //                 }
// //             }
// //         } catch (error) {
// //             console.error(error);
// //             statusBarItem.text = 'Vulnerability Check: Error';
// //             vscode.window.showErrorMessage('Failed to check vulnerability.');
// //         }
// //     };

// //     // Event listener for changes in the active text document
// //     vscode.workspace.onDidChangeTextDocument(async (event) => {
// //         const activeEditor = vscode.window.activeTextEditor;

// //         if (activeEditor && event.document === activeEditor.document) {
// //             const code = activeEditor.document.getText();

// //             // Check vulnerability on each change
// //             await checkVulnerability(code);
// //         }
// //     });

// //     // Register the manual command to check selected code for vulnerability
// //     let disposable = vscode.commands.registerCommand('extension.checkVulnerability', async () => {
// //         const editor = vscode.window.activeTextEditor;

// //         if (editor) {
// //             const code = editor.document.getText(editor.selection);

// //             if (!code) {
// //                 vscode.window.showErrorMessage('No code selected.');
// //                 return;
// //             }

// //             // Check vulnerability of the selected code
// //             await checkVulnerability(code);
// //         }
// //     });

// //     context.subscriptions.push(disposable);
// // }

// // // This method is called when your extension is deactivated
// // export function deactivate() {}










// ////////// VERSION 1 //////////////
// // import * as vscode from 'vscode';
// // import axios from 'axios';

// // export function activate(context: vscode.ExtensionContext) {
// //     // Create a status bar item for showing vulnerability status
// //     const statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 100);
// //     statusBarItem.text = 'Vulnerability Check: N/A';
// //     statusBarItem.show();

// //     // Function to check vulnerability of the code
// //     const checkVulnerability = async (code: string) => {
// //         if (!code) {
// //             statusBarItem.text = 'Vulnerability Check: No code detected';
// //             return;
// //         }

// //         try {
// //             // Send the updated code to the Flask server for vulnerability prediction
// //             console.time('Vulnerability Check Response Time');
// //             const response = await axios.post('http://127.0.0.1:5000/predict', { code });
// //             // const response = await axios.post('https://vul-det.onrender.com/predict', { code });
// //             const result = response.data;
// //             console.timeEnd('Vulnerability Check Response Time');

// //             // Update the status bar with the vulnerability status
// //             statusBarItem.text = `Vulnerability Check: ${result.vulnerability}`;
// //             vscode.window.showInformationMessage(`Vulnerability Check: ${result.vulnerability}`);

// //             // If vulnerable, apply the fix
// //             if (result.vulnerability === 'Vulnerable') {
// //                 const applyFix = await vscode.window.showInformationMessage('Vulnerability detected. Would you like to apply the fix?', 'Yes', 'No');
// //                 if (applyFix === 'Yes') {
// //                     // Apply the fix for SQL injection vulnerability
// //                     const fixedCode = applySqlFix(code);

// //                     // Update the document with the fixed code
// //                     const activeEditor = vscode.window.activeTextEditor;
// //                     if (activeEditor) {
// //                         const document = activeEditor.document;
// //                         const edit = new vscode.WorkspaceEdit();
// //                         const startPosition = new vscode.Position(0, 0);
// //                         const endPosition = document.lineAt(document.lineCount - 1).range.end;

// //                         // Replace the entire document content with the fixed code
// //                         edit.replace(document.uri, new vscode.Range(startPosition, endPosition), fixedCode);
// //                         await vscode.workspace.applyEdit(edit);
// //                     }

// //                     vscode.window.showInformationMessage('Fix applied successfully!');

// //                     // Recheck the code after applying the fix
// //                     await checkVulnerability(fixedCode);  // Send the fixed code for a new vulnerability check
// //                 }
// //             }
// //         } catch (error) {
// //             console.error(error);
// //             statusBarItem.text = 'Vulnerability Check: Error';
// //             vscode.window.showErrorMessage('Failed to check vulnerability.');
// //         }
// //     };

// //     // Function to apply fixes for common SQL injection vulnerabilities
// //     const applySqlFix = (code: string): string => {
// //         // Example fix: Replace direct concatenation with parameterized queries
// //         const sqlInjectionPattern = /"SELECT \* FROM users WHERE username = '([^']+)'"/g;
// //         const fixedCode = code.replace(sqlInjectionPattern, `SELECT * FROM users WHERE username = ?`);

// //         return fixedCode;
// //     };

// //     // Event listener for changes in the active text document
// //     vscode.workspace.onDidChangeTextDocument(async (event) => {
// //         const activeEditor = vscode.window.activeTextEditor;

// //         if (activeEditor && event.document === activeEditor.document) {
// //             const code = activeEditor.document.getText();

// //             // Check vulnerability on each change
// //             await checkVulnerability(code);
// //         }
// //     });

// //     // Register the manual command to check selected code for vulnerability
// //     let disposable = vscode.commands.registerCommand('extension.checkVulnerability', async () => {
// //         const editor = vscode.window.activeTextEditor;

// //         if (editor) {
// //             const code = editor.document.getText(editor.selection);

// //             if (!code) {
// //                 vscode.window.showErrorMessage('No code selected.');
// //                 return;
// //             }

// //             // Check vulnerability of the selected code
// //             await checkVulnerability(code);
// //         }
// //     });

// //     context.subscriptions.push(disposable);
// // }

// // // This method is called when your extension is deactivated
// // export function deactivate() {}











// // import * as vscode from 'vscode';
// // import axios from 'axios';

// // export function activate(context: vscode.ExtensionContext) {
// //     // Create a status bar item for showing vulnerability status
// //     const statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 100);
// //     statusBarItem.text = 'Vulnerability Check: N/A';
// //     statusBarItem.show();

// //     // Function to check vulnerability of the code
// //     const checkVulnerability = async (code: string) => {
// //         if (!code) {
// //             statusBarItem.text = 'Vulnerability Check: No code detected';
// //             return;
// //         }

// //         try {
// //             // Ensure the timer is cleared before starting a new one
// //             console.timeEnd('Vulnerability Check Response Time'); // Avoid duplicate timers
// //             console.time('Vulnerability Check Response Time'); // Start timer

// //             // Send the updated code to the Flask server for vulnerability prediction
// //             // const response = await axios.post('http://127.0.0.1:5000/predict', { code });
// //             const response = await axios.post('https://vul-det.onrender.com/predict', { code });

// //             // End the timer after receiving the response
// //             console.timeEnd('Vulnerability Check Response Time');

// //             const result = response.data;

// //             // Update the status bar with the vulnerability status
// //             statusBarItem.text = `Vulnerability Check: ${result.vulnerability}`;
// //             vscode.window.showInformationMessage(`Vulnerability Check: ${result.vulnerability}`);

// //             // If vulnerable, apply the fix
// //             if (result.vulnerability === 'Vulnerable') {
// //                 const applyFix = await vscode.window.showInformationMessage(
// //                     'Vulnerability detected. Would you like to apply the fix?',
// //                     'Yes', 'No'
// //                 );

// //                 if (applyFix === 'Yes') {
// //                     // Apply the fix for SQL injection vulnerability
// //                     const fixedCode = applySqlFix(code);

// //                     // Update the document with the fixed code
// //                     const activeEditor = vscode.window.activeTextEditor;
// //                     if (activeEditor) {
// //                         const document = activeEditor.document;
// //                         const edit = new vscode.WorkspaceEdit();
// //                         const startPosition = new vscode.Position(0, 0);
// //                         const endPosition = document.lineAt(document.lineCount - 1).range.end;

// //                         // Replace the entire document content with the fixed code
// //                         edit.replace(document.uri, new vscode.Range(startPosition, endPosition), fixedCode);
// //                         await vscode.workspace.applyEdit(edit);
// //                     }

// //                     vscode.window.showInformationMessage('Fix applied successfully!');

// //                     // Recheck the code after applying the fix
// //                     await checkVulnerability(fixedCode);
// //                 }
// //             }
// //         } catch (error) {
// //             console.error('Error checking vulnerability:', error);
// //             statusBarItem.text = 'Vulnerability Check: Error';
// //             vscode.window.showErrorMessage('Failed to check vulnerability.');
// //         } finally {
// //             // Ensure the timer always stops, even if an error occurs
// //             console.timeEnd('Vulnerability Check Response Time');
// //         }
// //     };

// //     // Function to apply fixes for common SQL injection vulnerabilities
// //     const applySqlFix = (code: string): string => {
// //         // Example fix: Replace direct concatenation with parameterized queries
// //         const sqlInjectionPattern = /"SELECT \* FROM users WHERE username = '([^']+)'"/g;
// //         const fixedCode = code.replace(sqlInjectionPattern, `SELECT * FROM users WHERE username = ?`);

// //         return fixedCode;
// //     };

// //     // Event listener for changes in the active text document
// //     vscode.workspace.onDidChangeTextDocument(async (event) => {
// //         const activeEditor = vscode.window.activeTextEditor;

// //         if (activeEditor && event.document === activeEditor.document) {
// //             const code = activeEditor.document.getText();

// //             // Check vulnerability on each change
// //             await checkVulnerability(code);
// //         }
// //     });

// //     // Register the manual command to check selected code for vulnerability
// //     let disposable = vscode.commands.registerCommand('extension.checkVulnerability', async () => {
// //         const editor = vscode.window.activeTextEditor;

// //         if (editor) {
// //             const code = editor.document.getText(editor.selection);

// //             if (!code) {
// //                 vscode.window.showErrorMessage('No code selected.');
// //                 return;
// //             }

// //             // Check vulnerability of the selected code
// //             await checkVulnerability(code);
// //         }
// //     });

// //     context.subscriptions.push(disposable);
// // }

// // // This method is called when your extension is deactivated
// // export function deactivate() {}



// //12/03/25


// // import * as vscode from 'vscode';
// // import axios from 'axios';

// // // Use local FastAPI server
// // const API_URL = 'http://127.0.0.1:8000/predict';

// // export function activate(context: vscode.ExtensionContext) {
// //     // Create a status bar item
// //     const statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 100);
// //     statusBarItem.text = 'Vulnerability Check: N/A';
// //     statusBarItem.show();

// //     // Function to check vulnerability
// //     const checkVulnerability = async (code: string) => {
// //         if (!code) {
// //             statusBarItem.text = 'Vulnerability Check: No code detected';
// //             return;
// //         }

// //         try {
// //             console.time('Vulnerability Check Response Time');

// //             // Send request to FastAPI
// //             const response = await axios.post(API_URL, { code });

// //             console.timeEnd('Vulnerability Check Response Time');

// //             const result = response.data;

// //             // Update the status bar
// //             statusBarItem.text = `Vulnerability Check: ${result.vulnerability}`;
// //             vscode.window.showInformationMessage(`Vulnerability Check: ${result.vulnerability}`);

// //             // If vulnerable, apply fix
// //             if (result.vulnerability === 'Vulnerable') {
// //                 const applyFix = await vscode.window.showInformationMessage(
// //                     'Vulnerability detected. Would you like to apply the fix?',
// //                     'Yes', 'No'
// //                 );

// //                 if (applyFix === 'Yes') {
// //                     const fixedCode = result.fixed_code;

// //                     // Update document
// //                     const activeEditor = vscode.window.activeTextEditor;
// //                     if (activeEditor) {
// //                         const document = activeEditor.document;
// //                         const edit = new vscode.WorkspaceEdit();
// //                         const startPosition = new vscode.Position(0, 0);
// //                         const endPosition = document.lineAt(document.lineCount - 1).range.end;

// //                         edit.replace(document.uri, new vscode.Range(startPosition, endPosition), fixedCode);
// //                         await vscode.workspace.applyEdit(edit);
// //                     }

// //                     vscode.window.showInformationMessage('Fix applied successfully!');
// //                     await checkVulnerability(fixedCode);
// //                 }
// //             }
// //         } catch (error) {
// //             console.error('Error checking vulnerability:', error);
// //             statusBarItem.text = 'Vulnerability Check: Error';
// //             vscode.window.showErrorMessage('Failed to check vulnerability.');
// //         }
// //     };

// //     // Detect changes in the document
// //     vscode.workspace.onDidChangeTextDocument(async (event) => {
// //         const activeEditor = vscode.window.activeTextEditor;
// //         if (activeEditor && event.document === activeEditor.document) {
// //             const code = activeEditor.document.getText();
// //             await checkVulnerability(code);
// //         }
// //     });

// //     // Register command for manual checking
// //     let disposable = vscode.commands.registerCommand('extension.checkVulnerability', async () => {
// //         const editor = vscode.window.activeTextEditor;
// //         if (editor) {
// //             const code = editor.document.getText(editor.selection);
// //             if (!code) {
// //                 vscode.window.showErrorMessage('No code selected.');
// //                 return;
// //             }
// //             await checkVulnerability(code);
// //         }
// //     });

// //     context.subscriptions.push(disposable);
// // }

// // export function deactivate() {}




// // import * as vscode from 'vscode';
// // import axios from 'axios';

// // // FastAPI server URL
// // const API_URL = 'http://127.0.0.1:8000/predict';

// // // Decoration style for highlighting vulnerabilities
// // const vulnerabilityDecorationType = vscode.window.createTextEditorDecorationType({
// //     backgroundColor: 'rgba(255, 0, 0, 0.3)', // Light red background
// //     border: '1px solid red' // Red border
// // });

// // // Function to check vulnerability and highlight code
// // const checkVulnerability = async (code: string, editor: vscode.TextEditor) => {
// //     if (!code) return;

// //     try {
// //         const response = await axios.post(API_URL, { code });
// //         const result = response.data;

// //         if (result.vulnerability === 'Vulnerable' && result.matches.length > 0) {
// //             vscode.window.showWarningMessage(" Vulnerability detected! Hover over highlighted parts.");

// //             let decorations: vscode.DecorationOptions[] = [];
// //             for (let match of result.matches) {
// //                 const start = editor.document.positionAt(match.start);
// //                 const end = editor.document.positionAt(match.end);
// //                 decorations.push({
// //                     range: new vscode.Range(start, end),
// //                     hoverMessage: ` Vulnerability: ${match.token}`
// //                 });
// //             }

// //             editor.setDecorations(vulnerabilityDecorationType, decorations);
// //         } else {
// //             editor.setDecorations(vulnerabilityDecorationType, []);
// //         }
// //     } catch (error) {
// //         console.error('Error checking vulnerability:', error);
// //         vscode.window.showErrorMessage('Failed to check vulnerability.');
// //     }
// // };

// // // Event listener for live vulnerability checking
// // export function activate(context: vscode.ExtensionContext) {
// //     vscode.workspace.onDidChangeTextDocument(async (event) => {
// //         const activeEditor = vscode.window.activeTextEditor;
// //         if (activeEditor && event.document === activeEditor.document) {
// //             const code = activeEditor.document.getText();
// //             await checkVulnerability(code, activeEditor);
// //         }
// //     });

// //     let disposable = vscode.commands.registerCommand('extension.checkVulnerability', async () => {
// //         const editor = vscode.window.activeTextEditor;
// //         if (editor) {
// //             const code = editor.document.getText();
// //             await checkVulnerability(code, editor);
// //         }
// //     });

// //     context.subscriptions.push(disposable);
// // }

// // export function deactivate() {}





// ////////// original /////////////////

// import * as vscode from 'vscode';
// import axios from 'axios';

// export function activate(context: vscode.ExtensionContext) {
//     // Create a status bar item for showing vulnerability status
//     const statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 100);
//     statusBarItem.text = 'Vulnerability Check: N/A';
//     statusBarItem.show();

//     // Function to check vulnerability of the code
//     const checkVulnerability = async (code: string) => {
//         if (!code) {
//             statusBarItem.text = 'Vulnerability Check: No code detected';
//             return;
//         }

//         try {
//             // Send the updated code to the Flask server for vulnerability prediction
//             const response = await axios.post('http://127.0.0.1:5000/predict', { code });
//             const result = response.data;

//             // Update the status bar with the vulnerability status
//             statusBarItem.text = `Vulnerability Check: ${result.vulnerability}`;
//             vscode.window.showInformationMessage(`Vulnerability Check: ${result.vulnerability}`);
//         } catch (error) {
//             console.error(error);
//             statusBarItem.text = 'Vulnerability Check: Error';
//             vscode.window.showErrorMessage('Failed to check vulnerability.');
//         }
//     };

//     // Event listener for changes in the active text document
//     vscode.workspace.onDidChangeTextDocument(async (event) => {
//         const activeEditor = vscode.window.activeTextEditor;

//         if (activeEditor && event.document === activeEditor.document) {
//             const code = activeEditor.document.getText();

//             // Check vulnerability on each change
//             await checkVulnerability(code);
//         }
//     });

//     // Register the manual command to check selected code for vulnerability
//     let disposable = vscode.commands.registerCommand('extension.checkVulnerability', async () => {
//         const editor = vscode.window.activeTextEditor;

//         if (editor) {
//             const code = editor.document.getText(editor.selection);

//             if (!code) {
//                 vscode.window.showErrorMessage('No code selected.');
//                 return;
//             }

//             // Check vulnerability of the selected code
//             await checkVulnerability(code);
//         }
//     });

//     context.subscriptions.push(disposable);
// }

// // This method is called when your extension is deactivated
// export function deactivate() {}



// ///////// highlighting ////////////
// // import * as vscode from 'vscode';
// // import axios from 'axios';

// // // Define a decoration type for highlighting vulnerabilities
// // const vulnerabilityDecorationType = vscode.window.createTextEditorDecorationType({
// //     backgroundColor: 'rgba(255,0,0,0.3)' // Light red highlight
// // });

// // // Create a status bar item for vulnerability status
// // const statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 100);
// // statusBarItem.text = 'Vulnerability Check: N/A';
// // statusBarItem.show();

// // // Function to check vulnerability and highlight lines
// // const checkVulnerability = async (editor: vscode.TextEditor) => {
// //     const code = editor.document.getText();
// //     if (!code) {
// //         statusBarItem.text = 'Vulnerability Check: No code detected';
// //         return;
// //     }

// //     try {
// //         // Send the code to the Flask API
// //         const response = await axios.post('http://127.0.0.1:5000/predict', { code });
// //         const result = response.data;

// //         // Ensure API response is correctly structured
// //         if (!result || !Array.isArray(result.vulnerable_lines)) {
// //             throw new Error("Invalid API response format");
// //         }

// //         // Clear previous highlights
// //         editor.setDecorations(vulnerabilityDecorationType, []);

// //         if (result.vulnerable_lines.length > 0) {
// //             // Highlight vulnerable lines
// //             let decorationsArray: vscode.DecorationOptions[] = [];
// //             result.vulnerable_lines.forEach((line: number) => {
// //                 const lineRange = new vscode.Range(line - 1, 0, line - 1, 1000);
// //                 decorationsArray.push({ range: lineRange });
// //             });

// //             editor.setDecorations(vulnerabilityDecorationType, decorationsArray);

// //             // Update status bar
// //             statusBarItem.text = `Vulnerability Check: ${result.vulnerable_lines.length} issue(s)`;
// //             vscode.window.showWarningMessage(`Vulnerability detected on lines: ${result.vulnerable_lines.join(", ")}`);
// //         } else {
// //             statusBarItem.text = 'Vulnerability Check: Safe';
// //             vscode.window.showInformationMessage("No vulnerabilities detected.");
// //         }
// //     } catch (error) {
// //         console.error("Error checking vulnerabilities:", error);
// //         statusBarItem.text = 'Vulnerability Check: Error';
// //         vscode.window.showErrorMessage("Failed to check vulnerability.");
// //     }
// // };

// // // Run vulnerability check on every text change
// // vscode.workspace.onDidChangeTextDocument(async (event) => {
// //     const activeEditor = vscode.window.activeTextEditor;
// //     if (activeEditor && event.document === activeEditor.document) {
// //         await checkVulnerability(activeEditor);
// //     }
// // });

// // // Command to manually check selected code
// // export function activate(context: vscode.ExtensionContext) {
// //     let disposable = vscode.commands.registerCommand('extension.checkVulnerability', async () => {
// //         const editor = vscode.window.activeTextEditor;
// //         if (editor) {
// //             await checkVulnerability(editor);
// //         }
// //     });

// //     context.subscriptions.push(disposable);
// // }

// // // This method is called when your extension is deactivated
// // export function deactivate() {}





// // import * as vscode from 'vscode';
// // import axios from 'axios';

// // export function activate(context: vscode.ExtensionContext) {
// //     // Create a status bar item for showing vulnerability status
// //     const statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 100);
// //     statusBarItem.text = 'Vulnerability Check: N/A';
// //     statusBarItem.show();

// //     // Function to check vulnerability of the code
// //     const checkVulnerability = async (code: string) => {
// //         if (!code) {
// //             statusBarItem.text = 'Vulnerability Check: No code detected';
// //             return;
// //         }

// //         try {
// //             // Send the updated code to the FastAPI server for vulnerability prediction
// //             const response = await axios.post('http://127.0.0.1:8000/docs/predict', { code });
// //             const result = response.data;

// //             // Update the status bar with the vulnerability status
// //             statusBarItem.text = `Vulnerability Check: ${result.vulnerability}`;
// //             vscode.window.showInformationMessage(`Vulnerability Check: ${result.vulnerability}`);
// //         } catch (error) {
// //             console.error(error);
// //             statusBarItem.text = 'Vulnerability Check: Error';
// //             vscode.window.showErrorMessage('Failed to check vulnerability.');
// //         }
// //     };

// //     // Event listener for changes in the active text document
// //     vscode.workspace.onDidChangeTextDocument(async (event) => {
// //         const activeEditor = vscode.window.activeTextEditor;

// //         if (activeEditor && event.document === activeEditor.document) {
// //             const code = activeEditor.document.getText();

// //             // Check vulnerability on each change
// //             await checkVulnerability(code);
// //         }
// //     });

// //     // Register the manual command to check selected code for vulnerability
// //     let disposable = vscode.commands.registerCommand('extension.checkVulnerability', async () => {
// //         const editor = vscode.window.activeTextEditor;

// //         if (editor) {
// //             const code = editor.document.getText(editor.selection);

// //             if (!code) {
// //                 vscode.window.showErrorMessage('No code selected.');
// //                 return;
// //             }

// //             // Check vulnerability of the selected code
// //             await checkVulnerability(code);
// //         }
// //     });

// //     context.subscriptions.push(disposable);
// // }

// // // This method is called when your extension is deactivated
// // export function deactivate() {}



// import * as vscode from 'vscode';
// import axios from 'axios';

// export function activate(context: vscode.ExtensionContext) {
//     // Create a status bar item for showing vulnerability status
//     const statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 100);
//     statusBarItem.text = 'Vulnerability Check: N/A';
//     statusBarItem.show();

//     // Function to check vulnerability of the code
//     const checkVulnerability = async (code: string) => {
//         if (!code) {
//             statusBarItem.text = 'Vulnerability Check: No code detected';
//             return;
//         }

//         try {
//             // Send the updated code to the Flask server for vulnerability prediction
//             const response = await axios.post('http://127.0.0.1:5000/predict', { code });
//             const result = response.data;

//             // Update the status bar with the vulnerability status
//             statusBarItem.text = `Vulnerability Check: ${result.vulnerability}`;
//             vscode.window.showInformationMessage(`Vulnerability Check: ${result.vulnerability}`);
//         } catch (error) {
//             console.error(error);
//             statusBarItem.text = 'Vulnerability Check: Error';
//             vscode.window.showErrorMessage('Failed to check vulnerability.');
//         }
//     };

//     // Event listener for changes in the active text document
//     vscode.workspace.onDidChangeTextDocument(async (event) => {
//         const activeEditor = vscode.window.activeTextEditor;

//         if (activeEditor && event.document === activeEditor.document) {
//             const code = activeEditor.document.getText();

//             // Check vulnerability on each change
//             await checkVulnerability(code);
//         }
//     });

//     // Register the manual command to check selected code for vulnerability
//     let disposable = vscode.commands.registerCommand('extension.checkVulnerability', async () => {
//         const editor = vscode.window.activeTextEditor;

//         if (editor) {
//             const code = editor.document.getText(editor.selection);

//             if (!code) {
//                 vscode.window.showErrorMessage('No code selected.');
//                 return;
//             }

//             // Check vulnerability of the selected code
//             await checkVulnerability(code);
//         }
//     });

//     context.subscriptions.push(disposable);
// }

// // This method is called when your extension is deactivated
// export function deactivate() {}



import * as vscode from 'vscode';
import axios from 'axios';

export function activate(context: vscode.ExtensionContext) {
    // Create a status bar item for showing vulnerability status
    const statusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left, 100);
    statusBarItem.text = 'Vulnerability Check: N/A';
    statusBarItem.show();

    let lastRequestTime = 0;
    const REQUEST_DELAY = 2000; // 2 seconds delay between API requests

    // Function to check vulnerability of the code
    const checkVulnerability = async (code: string) => {
        const now = Date.now();
        if (now - lastRequestTime < REQUEST_DELAY) return; // Prevent spamming API
        lastRequestTime = now;

        if (!code || code.length > 5000) { // Prevent empty or excessively long code
            statusBarItem.text = 'Vulnerability Check: No valid code detected';
            return;
        }

        statusBarItem.text = 'Vulnerability Check: Checking...';

        try {
            const response = await axios.post(
                'https://vuln-det-api-569954300851.asia-south1.run.app/predict',
                { code },
                { timeout: 20000 } // Set timeout to avoid hanging requests
            );
            const result = response.data;

            // Update the status bar with the vulnerability status
            statusBarItem.text = `Vulnerability Check: ${result.vulnerability}`;
            vscode.window.showInformationMessage(`Vulnerability Check: ${result.vulnerability}`);
        } catch (error: any) {
            console.error("Error in API Call:", error.response?.data || error.message);
            statusBarItem.text = 'Vulnerability Check: Error';
            vscode.window.showErrorMessage(`Failed to check vulnerability: ${error.response?.data?.error || error.message}`);
        }
    };

    // Event listener for changes in the active text document
    vscode.workspace.onDidChangeTextDocument(async (event) => {
        const activeEditor = vscode.window.activeTextEditor;

        if (activeEditor && event.document === activeEditor.document) {
            const code = activeEditor.document.getText();
            await checkVulnerability(code);
        }
    });

    // Register the manual command to check selected code for vulnerability
    let disposable = vscode.commands.registerCommand('extension.checkVulnerability', async () => {
        const editor = vscode.window.activeTextEditor;

        if (editor) {
            const code = editor.document.getText(editor.selection);

            if (!code) {
                vscode.window.showErrorMessage('No code selected.');
                return;
            }

            await checkVulnerability(code);
        }
    });

    context.subscriptions.push(disposable);
}

// This method is called when your extension is deactivated
export function deactivate() {}
